### 자연수(양의 정수 + 0)

이진법

### 정수(음수)

#### 부호와 크기 표현법

| 부호  | 각 자릿수 | 10진수 |
| --- | ----- | ---- |
| 0   | 111   | +7   |
| 0   | 110   | +6   |
| 0   | 101   | +5   |
| 0   | 100   | +4   |
| 0   | 011   | +3   |
| 0   | 010   | +2   |
| 0   | 001   | +1   |
| 0   | 000   | +0   |
| 1   | 000   | -0   |
| 1   | 001   | -1   |
| 1   | 010   | -2   |
| 1   | 011   | -3   |
| 1   | 100   | -4   |
| 1   | 101   | -5   |
| 1   | 110   | -6   |
| 1   | 111   | -7   |

수의 제일 앞 비트는 부호를 나타낸다.
가장 편해 보이지만 이는 0을 표현하는 방법이 2개이기에 낭비되는 비트가 발생하고 양수와 음수의 합을 구하기가 쉽지 않다.

```text
  0 0 0 1 | 1
+ 1 0 0 1 | -1
--------------
  1 0 1 0 | -2
```

#### 1의 보수 표현법

| 부호  | 각 자릿수 | 10진수 |
| --- | ----- | ---- |
| 0   | 111   | +7   |
| 0   | 110   | +6   |
| 0   | 101   | +5   |
| 0   | 100   | +4   |
| 0   | 011   | +3   |
| 0   | 010   | +2   |
| 0   | 001   | +1   |
| 0   | 000   | +0   |
| 1   | 111   | -0   |
| 1   | 110   | -1   |
| 1   | 101   | -2   |
| 1   | 100   | -3   |
| 1   | 011   | -4   |
| 1   | 010   | -5   |
| 1   | 001   | -6   |
| 1   | 000   | -7   |

양수의 모든 비트를 뒤집는다.
합을 구할때는 조금 나아졌지만 추가적인 연산이 필요하고 여전히 0을 표현하는 비트가 2개이다.

```
  0 0 1 0 | 2
+ 1 1 1 0 | -1
--------------
1 0 0 0 0 | ?  MSB를 넘어가는 비트는 순환올림으로 LSB로 전달
--------------
  0 0 0 1 | 1
```

#### 2의 보수 표현법

| 부호  | 각 자릿수 | 10진수 |
| --- | ----- | ---- |
| 0   | 111   | +7   |
| 0   | 110   | +6   |
| 0   | 101   | +5   |
| 0   | 100   | +4   |
| 0   | 011   | +3   |
| 0   | 010   | +2   |
| 0   | 001   | +1   |
| 0   | 000   | +0   |
| 1   | 111   | -1   |
| 1   | 110   | -2   |
| 1   | 101   | -3   |
| 1   | 100   | -4   |
| 1   | 011   | -5   |
| 1   | 010   | -6   |
| 1   | 001   | -7   |
| 1   | 000   | -8   |

각 자리의 비트를 뒤집고 1을 더하는데 MSB에서 올림이 발생하면 버린다.

```
  0 0 0 1 | 1
+ 1 1 1 1 | -1
--------------
1 0 0 0 0 | MSB를 넘어가는 비트는 버림
--------------
  0 0 0 0 | 0
```

### 실수

#### 고정소수점

| 정수부분 | 소숫점 | 분수부분 | 값     |
| ---- | --- | ---- | ----- |
| 00   | .   | 00   | 0     |
| 00   | .   | 01   | 1/4   |
| 00   | .   | 10   | 1/2   |
| 00   | .   | 11   | 3/4   |
| 01   | .   | 00   | 1     |
| 01   | .   | 01   | 1 1/4 |
| 01   | .   | 10   | 1 1/2 |
| 01   | .   | 11   | 1 3/4 |
| 10   | .   | 00   | 2     |
| 10   | .   | 01   | 2 1/4 |
| 10   | .   | 10   | 2 1/2 |
| 10   | .   | 11   | 2 3/4 |
| 11   | .   | 00   | 3     |
| 11   | .   | 01   | 3 1/4 |
| 11   | .   | 10   | 3 1/2 |
| 11   | .   | 11   | 3 3/4 |

10진수의 경우 소숫점 아래 첫번째 수는 1/10, 두번째는 1/100이듯이 2진수의 경우 소숫점 아래 첫번째 수는 1/2, 두번째 수는 1/4(1/2^2)이다.
이런 방식의 경우 플랑크 상수(6.63 \* 10^-34), 아보가드로 수(6.02 \* 10^23)과 같은 상수를 표현하려면 엄청난 양의 비트가 필요하다.

#### 부동소수점

| 가수  | 지수  | 값                 |
| --- | --- | ----------------- |
| 0.0 | 00  | 0(0 \* 2^0)       |
| 0.0 | 01  | 0(0 \* 2^1)       |
| 0.0 | 10  | 0(0 \* 2^2)       |
| 0.0 | 11  | 0(0 \* 2^3)       |
| 0.1 | 00  | 0.5(1/2 \* 2^0)   |
| 0.1 | 01  | 1(1/2 \* 2^1)     |
| 0.1 | 10  | 2(1/2 \* 2^2)     |
| 0.1 | 11  | 4(1/2 \* 2^3)     |
| 1.0 | 00  | 1(1 \* 2^0)       |
| 1.0 | 01  | 2(1 \* 2^1)       |
| 1.0 | 10  | 4(1 \* 2^2)       |
| 1.0 | 11  | 8(1 \* 2^3)       |
| 1.1 | 00  | 1.5(1 1/2 \* 2^0) |
| 1.1 | 01  | 3(1 1/2 \* 2^1)   |
| 1.1 | 10  | 6(1 1/2 \* 2^2)   |
| 1.1 | 11  | 12(1 1/2 \* 2^3)  |

이는 0을 표현하는 비트가 4개에 2도 2개, 4도 2개이긴 하지만 더 적은 비트로 더 넓은 범위의 값을 표현할 수 있다는 점에서 실수를 표현하는 표준 방법이다. 이를 표준화하기 위해 IEEE(미국 전자전기공학회, Institute of Electrical and Electronic Engineers)에서 이에 관한 표준을 만들었다. NaN, 무한대, 0 등을 표현하는 비트와 지수의 첫번째 비트는 반드시 1로 하고, 반드시 1이기에 이를 생략하여 1개의 비트를 추가로 사용가능하게 하는 등의 기능을 정해놓았다.  
기본정밀도 부동소수점과 2배 정밀도 부동소수점이 있다는 정도만 알면 될 것 같다.

![KakaoTalk_20171222_122202517](https://i.imgur.com/sRBfNiu.png)

위는 기본정밀도(32bit) 아래는 2배정밀도(64bit) 부동소수점 표현 방법이다.

### 추가 내용

```python
print(bin(7))   # 0b111
print(bin(-7))  # -0b111
print(bin(~7))  # -0b1000
print(7 & -7)   # 1
```

헷갈릴 수 있겠지만 이는 실제 컴퓨터가 사용하는 비트와는 별개로 사용자가 이해하기 쉽게 보여주기위한 내용이기에 이렇게 나온다.
