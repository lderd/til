### 장점

테이블을 검색하는 속도와 성능의 향상

### 단점

인덱스를 관리하는데 추가작업이 필요 (인덱스를 읽고 수정하는데에 비용 발생)

잘못 사용할 경우 성능 저하



### B - 트리, B * 트리, B + 트리

#### 균형 이진 트리

리프 노드의 레벨 차이가 최대 1인 트리

![스크린샷 2021-04-22 오후 4 49 23](https://user-images.githubusercontent.com/44339530/115676587-b1e01880-a38a-11eb-9f79-cc2ab891371f.png)

#### B - 트리

[B-트리 생성](https://www.cs.usfca.edu/~galles/visualization/BTree.html)

B트리라고도 하고 하나의 노드에 여러개의 정보를 가질 수 있고 두 개 이상의 자식을 가질 수 있다.

저장할 내용이 커지게 되면서 이 내용을 HDD나 SSD와 같은 외부 기억장치에 저장할 필요가 생기는데 이런 외부 기억장치는 블럭단위로 파일을 입출력함. 이때 입츌력의 비용은 파일의 크기와 상관 없음. 즉, 1KB의 블럭에 1KB의 파일이 저장되어 있으나 1byte가 저장되어 있으나 입출력의 비용이 같다는 말임. 그렇다면 **하나의 블럭을 최대로 활용**하는 것이 좋음.

![](https://blog.kakaocdn.net/dn/Svp6z/btrdEi9c2DR/R4Dnmqkl8RWcqQPBACI9fK/img.png)

##### 특징

- 각 노드의 자료는 정렬되어 있음

- 자료는 중복되지 않음

- 모든 리프노드는 같은 레벨

#### B + 트리

[B+트리 생성](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)

값들은 모두 리프노드에 연결리스트의 형태로 들어가 있음

![](https://blog.kakaocdn.net/dn/bAARBC/btrdDydoUp7/9h4KOXBRyDNKpKDAe2ugq0/img.png)

##### 특징

- 모든 값이 리프노드에 있기 때문에 그 외의 노드는 메모리를 더 확보할 수 있고 더 많은 포인터가 들어갈 수 있기에 트리의 높이가 더 낮아질 수 있다

- 모든 값이 리프노드에 있기에 값을 확인하려면 결국 리프노드까지 탐색해야함



#### B * 트리

B-트리의 변형

노드의 생성과 추가적인 연산을 최소화 시킴

값을 추가할 때 노드를 분리하지 않고 키값과 포인터를 재분배하여 형제노드로 이동시킴

새로운 메모리를 할당하는 것이 아니라 기존에 있는 노드로 이동시키기 때문에 비용이 적게 든다


